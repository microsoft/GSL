///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef GSL_ALGORITHM_H
#define GSL_ALGORITHM_H

#include "span"
#include <algorithm>

#ifdef _MSC_VER

#pragma warning(push)

// turn off some warnings that are noisy about our Expects statements
#pragma warning(disable : 4127) // conditional expression is constant

// blanket turn off warnings from CppCoreCheck for now
// so people aren't annoyed by them when running the tool.
// more targeted suppressions will be added in a future update to the GSL
#pragma warning(disable : 26481 26482 26483 26485 26490 26491 26492 26493 26495)

#endif // _MSC_VER

namespace gsl
{

template <class SrcElementType, std::ptrdiff_t SrcExtent,
          class DestElementType, std::ptrdiff_t DestExtent>
void copy(span<SrcElementType, SrcExtent> src, span<DestElementType, DestExtent> dest)
{
    static_assert(std::is_assignable<decltype(*dest.data()), decltype(*src.data())>::value,
                  "Elements of source span can not be assigned to elements of destination span");
    static_assert(SrcExtent == dynamic_extent || DestExtent == dynamic_extent ||
                      (SrcExtent <= DestExtent),
                  "Source range is longer than target range");

    Expects(dest.size() >= src.size());
    std::copy_n(src.data(), src.size(), dest.data());
}

namespace details_algo
{
    template <class ElementType, std::ptrdiff_t SrcExtent>
    auto toIt(const span<ElementType, SrcExtent>& rng, const ElementType* ptr) -> decltype(rng.begin())
    {
        return rng.begin() + (ptr - rng.data());
    }
}

// find
template <class SrcElementType, std::ptrdiff_t SrcExtent, class T>
auto find(const span<SrcElementType, SrcExtent>& rng, const T& value) -> decltype(rng.begin())
{
    auto* ptr = std::find(rng.data(), rng.data() + rng.size(), value);
    return details_algo::toIt(rng, ptr);
}

template <class SrcElementType, std::ptrdiff_t SrcExtent, class UnaryPredicate>
auto find_if(const span<SrcElementType, SrcExtent>& rng, UnaryPredicate p) -> decltype(rng.begin())
{
    auto* ptr = std::find_if(rng.data(), rng.data() + rng.size(), p);
    return details_algo::toIt(rng, ptr);
}

template <class SrcElementType, std::ptrdiff_t SrcExtent, class UnaryPredicate>
auto find_if_not(const span<SrcElementType, SrcExtent>& rng, UnaryPredicate p) -> decltype(rng.begin())
{
    auto* ptr = std::find_if_not(rng.data(), rng.data() + rng.size(), p);
    return details_algo::toIt(rng, ptr);
}

// lower_bound
template <class SrcElementType, std::ptrdiff_t SrcExtent, class T>
auto lower_bound(const span<SrcElementType, SrcExtent>& rng, const T& value) -> decltype(rng.begin())
{
    auto* ptr = std::lower_bound(rng.data(), rng.data() + rng.size(), value);
    return details_algo::toIt(rng, ptr);
}

template <class SrcElementType, std::ptrdiff_t SrcExtent, class T, class Compare>
auto lower_bound(const span<SrcElementType, SrcExtent>& rng, const T& value, Compare comp) -> decltype(rng.begin())
{
    auto* ptr = std::lower_bound(rng.data(), rng.data() + rng.size(), value, comp);
    return details_algo::toIt(rng, ptr);
}

// upper_bound
template <class SrcElementType, std::ptrdiff_t SrcExtent, class T>
auto upper_bound(const span<SrcElementType, SrcExtent>& rng, const T& value) -> decltype(rng.begin())
{
    auto* ptr = std::upper_bound(rng.data(), rng.data() + rng.size(), value);
    return details_algo::toIt(rng, ptr);
}

template <class SrcElementType, std::ptrdiff_t SrcExtent, class T, class Compare>
auto upper_bound(const span<SrcElementType, SrcExtent>& rng, const T& value, Compare comp) -> decltype(rng.begin())
{
    auto* ptr = std::upper_bound(rng.data(), rng.data() + rng.size(), value, comp);
    return details_algo::toIt(rng, ptr);
}

// binary_search
template <class SrcElementType, std::ptrdiff_t SrcExtent, class T>
bool binary_search(span<SrcElementType, SrcExtent> rng, const T& value)
{
    return std::binary_search(rng.data(), rng.data() + rng.size(), value);
}

template <class SrcElementType, std::ptrdiff_t SrcExtent, class T, class Compare>
bool binary_search(span<SrcElementType, SrcExtent> rng, const T& value, Compare comp)
{
    return std::binary_search(rng.data(), rng.data() + rng.size(), value, comp);
}

// sort
template <class SrcElementType, std::ptrdiff_t SrcExtent>
void sort(span<SrcElementType, SrcExtent> rng)
{
    std::sort(rng.data(), rng.data() + rng.size());
}

template <class SrcElementType, std::ptrdiff_t SrcExtent, class Compare>
void sort(span<SrcElementType, SrcExtent> rng, Compare comp)
{
    std::sort(rng.data(), rng.data() + rng.size(), comp);
}

// stable sort
template <class SrcElementType, std::ptrdiff_t SrcExtent>
void stable_sort(span<SrcElementType, SrcExtent> rng)
{
    std::stable_sort(rng.data(), rng.data() + rng.size());
}

template <class SrcElementType, std::ptrdiff_t SrcExtent, class Compare>
void stable_sort(span<SrcElementType, SrcExtent> rng, Compare comp)
{
    std::stable_sort(rng.data(), rng.data() + rng.size(), comp);
}

// nth_element
template <class SrcElementType, std::ptrdiff_t SrcExtent>
void nth_element(span<SrcElementType, SrcExtent> rng,
	typename span<SrcElementType, SrcExtent>::index_type nth)
{
	std::nth_element(rng.data(), &rng[nth], rng.data() + rng.size());
}

template <class SrcElementType, std::ptrdiff_t SrcExtent, class Compare>
void nth_element(span<SrcElementType, SrcExtent> rng,
	typename span<SrcElementType, SrcExtent>::index_type nth, Compare comp)
{
	std::nth_element(rng.data(), &rng[nth], rng.data() + rng.size(), comp);
}

} // namespace gsl

#ifdef _MSC_VER
#pragma warning(pop)
#endif // _MSC_VER

#endif // GSL_ALGORITHM_H
